# -*- coding: utf-8 -*-
"""Grad-CAM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NbDFVNaPW9jlNvycyr_nIKsecfoiMeRp
"""

import os
import numpy as np
import cv2
import tensorflow as tf
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from sklearn.model_selection import train_test_split
from sklearn.utils import shuffle
import matplotlib.pyplot as plt
import matplotlib.cm as cm
from google.colab import drive

drive.mount('/content/drive')

import os
import cv2
import numpy as np
import tensorflow as tf

# Define constants
image_size = 150
labels = ['glioma', 'meningioma', 'notumor', 'pituitary']
X_data = []
Y_data = []

# Use generator-style approach to avoid loading all at once
def load_images_in_batches(base_path, labels, image_size, max_images_per_class=500):
    X = []
    Y = []
    for label in labels:
        count = 0
        for folder in ['Training', 'Testing']:
            folder_path = os.path.join(base_path, folder, label)
            files = os.listdir(folder_path)
            for file in files:
                if count >= max_images_per_class:
                    break
                img_path = os.path.join(folder_path, file)
                img = cv2.imread(img_path)
                if img is not None:
                    img = cv2.resize(img, (image_size, image_size))
                    X.append(img / 255.0)  # Normalize on the fly
                    Y.append(labels.index(label))
                    count += 1
    return np.array(X, dtype=np.float32), tf.keras.utils.to_categorical(Y, num_classes=len(labels))

# Path to your dataset
base_path = '/content/drive/MyDrive/Final Year Project'

# Load limited number of images per class to avoid RAM crash
X_data, Y_data = load_images_in_batches(base_path, labels, image_size, max_images_per_class=500)

X_data, Y_data = shuffle(X_data, Y_data, random_state=42)
X_train, X_test, y_train, y_test = train_test_split(X_data, Y_data, test_size=0.1, random_state=42)

model = Sequential()
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(150, 150, 3)))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(2, 2))
model.add(Dropout(0.3))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(Dropout(0.3))
model.add(MaxPooling2D(2, 2))
model.add(Dropout(0.3))
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D(2, 2))
model.add(Dropout(0.3))
model.add(Conv2D(128, (3, 3), activation='relu', name='last_conv'))  # Name this for Grad-CAM
model.add(Conv2D(256, (3, 3), activation='relu'))
model.add(MaxPooling2D(2, 2))
model.add(Dropout(0.3))
model.add(Flatten())
model.add(Dense(512, activation='relu'))
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.3))
model.add(Dense(4, activation='softmax'))

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
model.summary()

history = model.fit(X_train, y_train, epochs=10, validation_split=0.1)

plt.plot(history.history['accuracy'], label='Train Acc')
plt.plot(history.history['val_accuracy'], label='Val Acc')
plt.title('Accuracy')
plt.legend()
plt.show()

plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.title('Loss')
plt.legend()
plt.show()

def make_gradcam_heatmap(img_array, model, last_conv_layer_name, pred_index=None):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer(last_conv_layer_name).output, model.output]
    )
    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_array)
        if pred_index is None:
            pred_index = tf.argmax(predictions[0])
        class_channel = predictions[:, pred_index]

    grads = tape.gradient(class_channel, conv_outputs)
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))
    conv_outputs = conv_outputs[0]
    heatmap = conv_outputs @ pooled_grads[..., tf.newaxis]
    heatmap = tf.squeeze(heatmap)
    heatmap = tf.maximum(heatmap, 0) / tf.math.reduce_max(heatmap)
    return heatmap

img_path = '/content/drive/MyDrive/Final Year Project/Testing/pituitary/Te-piTr_0009.jpg'
img = cv2.imread(img_path)
img = cv2.resize(img, (150, 150))
img_norm = img / 255.0
img_array = np.expand_dims(img_norm, axis=0)

prediction = model.predict(img_array)
predicted_class = np.argmax(prediction[0])
print("Predicted Tumor Type:", labels[predicted_class])

# Example: Grad-CAM for MobileNetV2
import tensorflow as tf
import numpy as np

# Load model
model = tf.keras.applications.MobileNetV2(weights='imagenet')
img_size = (224, 224)

# Load and preprocess image
img = tf.keras.preprocessing.image.load_img('/content/drive/MyDrive/Final Year Project/Testing/pituitary/Te-piTr_0009.jpg', target_size=img_size)
img_array = tf.keras.preprocessing.image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = tf.keras.applications.mobilenet_v2.preprocess_input(img_array)

# Call model to build it
_ = model(img_array)

# Check correct conv layer name
for layer in model.layers[::-1]:
    if isinstance(layer, tf.keras.layers.Conv2D):
        print("Last conv layer:", layer.name)
        break

# Assuming last conv layer is 'Conv_1'
heatmap = make_gradcam_heatmap(img_array, model, 'Conv_1')

from matplotlib import cm
import cv2
import numpy as np

# Convert PIL image to NumPy array if needed
img_np = np.array(img)  # img is the original PIL image

# Resize heatmap to match image size
heatmap_resized = cv2.resize(heatmap.numpy(), (img_np.shape[1], img_np.shape[0]))

# Convert to 0-255 and uint8
heatmap_uint8 = np.uint8(255 * heatmap_resized)

# Apply colormap
colormap = cm.get_cmap('jet')
heatmap_color = colormap(heatmap_uint8)  # shape: (H, W, 4)
heatmap_color = np.delete(heatmap_color, 3, axis=2)  # Remove alpha channel
heatmap_color = np.uint8(255 * heatmap_color)

# Superimpose heatmap on image
superimposed_img = cv2.addWeighted(img_np, 0.6, heatmap_color, 0.4, 0)

import matplotlib.pyplot as plt
import cv2
import numpy as np

# Convert PIL image to NumPy array
img_np = np.array(img)

# Convert from BGR to RGB (only if using OpenCV image, but since this is from PIL, it's already RGB)
# If you *must* use cv2.cvtColor (e.g., if the image is in BGR), convert it like this:
# img_rgb = cv2.cvtColor(img_np, cv2.COLOR_BGR2RGB)

# But since img from PIL is already RGB, you can skip cv2 and use directly:
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.title("Original Image")
plt.imshow(img_np)  # already RGB
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Grad-CAM Overlay")
plt.imshow(cv2.cvtColor(superimposed_img, cv2.COLOR_BGR2RGB))
plt.axis('off')
plt.show()